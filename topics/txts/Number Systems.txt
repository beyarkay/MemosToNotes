= UCT Department of Computer Science CSC1015F

Number Systems and Logic

ASLAM SAFLA
<ASLAM@CS.UCT.AC.ZA>

8 UNIVERSITY OF CAPE TOWNSignpost
We need to use binary representations for kind of data.

¢ Computers operate on binary values (as a
consequence of being built from transistors).
¢ Bit = “Binary digit”
¢ Building a computer using base 10 would be much much
much more difficult than using binary.

In a computer chip, transistors switch between two binary
states -- 0 and 1.

One computer chip can have millions of transistors
continually switching, to complete complex calculations.

8 UNIVERSITY OF CAPE TOWN ESigned Numbers (representing positive and
negative numbers without a ‘-’ sign

Can use left-most bit to code sign (sign and magnitude)
= O=positive and 1=negative
= Gives symmetric numbers from -(2’-1)...2’-1 AND two zeros!
= This is wasteful: can use extra bit pattern.
= Addition not straight-forward (bad for hardware implementors).

Try one's complement representation:
= negative numbers obtained by flipping signs.
= positive numbers unchanged.
m €.g. -5;) = complement(00000101,) = 11111010,

oLeft-most bit still indicates sign.
oGives symmetric numbers from -(27-1)...2’-1 AND two zeros.
oAddition easier.

8 UNIVERSITY OF CAPE TOWN2's Complement Addition

1’s Complement still has two Zeros.

An alternative to address this is two’s complement
= Complement then add 1
=m Our number range is now asymmetric: -2’...27-1
= Used extra zero bit pattern
o 7=0111... 2=0010, 1 = 0001 ;
Current computing

0 = 0000
-1= 1111, -2= 1110... -8 = 1000 components

Now when we add, discard carry Principal advantages

10-7 over 1’s complement is
= 00001010 + 2complement(000001 11) single zero, and that the

= 00001010 + 11111001
= 00000011 carry 1 (discard)
=3

8 UNIVERSITY OF CAPE TOWN ENegative number representations

To get the negative representation for a positive
number:

two's complement. invert all bits, then add one.
one's complement. invert all bits.
sign/magnitude: invert just the sign bit.

8 UNIVERSITY OF CAPE TOWNAlternative for unsigned numbers:
Binary Coded Decimal

Can use Binary Coded Decimal (BCD) to represent
integers.
= Map 4 bits per digit (from 0000 to 1001)
Wasteful: only 10 bit patterns required — 6 are wasted.
Binary code is more compact code.
=m Example:
4 256, = 100000000, = 0010 0101 0110g¢p
o ... 9vs 12 bits in this case
Complicates hardware implementation.
= How to add/subtract, deal with carries etc.
But more readable, most pocket calculators do all the
calculations in BCD.

8 UNIVERSITY OF CAPE TOWNOctal and Hexadecimal

Base 8 (octal) and base 16 (Hexadecimal) are
sometimes used to concisely represent binary (both
are powers of 2).

Octal uses digits 0-7.

Hex uses “digits” 0-9, A-F.
Examples: 17,, = 10001, = 21, = 114,

Conversion as for decimal to binary:
= divide/multiply by 8 or 16 instead

Binary to octal or hexadecimal is simple:
= group bits into 3 (octal) or 4 (hex) from LS bit.
= pad with leading zeros if required.

8 UNIVERSITY OF CAPE TOWNHexadecimal colours in HTML (and
elsewhere)

Typical HTML code to create
background colors:
<body bgcolor="#FFFFFF"> for an all
white background
<body bgcolor="#CCCCCC"> fora
light-gray background

The three PRIMARY colors (RED,
GREEN and BLUE) each assigned
TWO HEXADECIMAL DIGITS (=1
byte).

8 UNIVERSITY OF CAPE TOWN

 

White
Silver
Gray
Black
Red
Maroon
Yellow
Olive
Lime
Green
Aqua
Teal
Blue
Navy
Fuchsia

Purple

#FFFFFF

#COcoco

#808080

#000000

#FFO000

#800000

#FFFFOO

#808000

#00FFOO

#008000

#00FFFF

#008080

#0000FF

#000080

#FFOOFF

#800080Floating Point Numbers

Fixed point numbers have very limited range (determined by bit
length).
A 32-bit value can hold integers from -23' to 2°'-1 or smaller
range of fixed point fractional values.
O Solution: use floating point (scientific notation)

Thus 0.0000000000000976 = 9.76*10-"4

Consists of two parts: mantissa & exponent

= Mantissa: the number multiplying the base 9.76*10°'4
= Exponent: the power

O The significand is the part of the mantissa after the decimal
point 9.76*10°14

8 UNIVERSITY OF CAPE TOWNFloating Point Range

Range of numbers is very large, but accuracy is limited
by significand.
O So, for 8 digits of precision in decimal:
976375297321 = 9.7637529*10""',
and we lose accuracy (truncation error)

We can normalise any floating point number:
34.34*101* = 3.434*10'8

O Shift point until only one non-zero digit is to left.
= add 1 to exponent for each left shift
= subtract 1 for each right shift

8 UNIVERSITY OF CAPE TOWNBinary Floating Point

oO We can use FP notation for binary: use base of 2
0.111001*23 = 1.11001*24 = 1.11001 * 211111100 (d's
complement exponent)
oO For binary FP numbers, normalise to:
1.XXX...XXX*2YY- VY
oO Problems with FP:
= any different floating point formats; problems exchanging
ala.
= FP arithmetic not associative: x + (y +z) l= (x+y) +zZ

x=(0.1+0.2)+0.3
y=0.1+(0.2+0.3)
>>> X==Vy

False

8 UNIVERSITY OF CAPE TOWNFloating Point Formats

IEEE 754 format introduced: single (32-bit) and double (64-bit)
formats; much needed standard!
= Also extended precision - 80 bits (long double).
oO Single precision number represented internally as
= sign bit
= followed by exponent (8-bits)
m then the fractional part of normalised number (23 bits)
oO The leading 1 is implied; not stored.
oO Double precision
=m has 11-bit exponent and
m 52-bit significand
O Single precision range: 2*10°* to 2*10%8
O Double range: 2*10° to 2*1090

31| 30| 29 zs] 27| 26| 25 24 23] 22| 21|20 19] 18| 17| 16] 15] 14] 1a] 12] 44] 10| >| e| 7] 6| 5| a] 2] 2 1] 0
3 Exponent 3 bits Signticand 23 bits

 

 

 

 

 

 

8 UNIVERSITY Ol IEEE 754 - Single (32-bit) floating point format ESignpost
Bits are bundled together into 8-bit collections,

called bytes.

With these bytes, there are 3 types of data we want to
represent:

¢ integers (both positive and negative)
¢ floating point values
¢ characters

8 UNIVERSITY OF CAPE TOWNFloating Point Templates

[#1] 30] 29] 28 27] 26] 25] 24] 23] 22 21] 2a| 19] 49] 17] 16] 15] 14] +3] 12] 14] 40] 9] 8] 7 6] 5] 4] 3] 2] 4

 

Signticand _20 bits
Significand (cont'd) 32-bits

IEEE ¥54- Double (64-bit) floating point tormat

31) 30) 29 28) 27) 26) 35 24 23) 22) 21/20 19) 18) WF) 16) 15) 14) 13) 12) 11, 10) 9) By 7) G&| S| 4) 3) 2 1] O

Ls | Exponent 4 bits Signficand 23 bits

IEEE 754 - Single (32-bit) floating polnt format

8 UNIVERSITY OF CAPE TOWN EFloating Point Exponents

The exponent is “biased: no explicit negative number.
OSingle precision: 127, Double precision 1023

oOSo, for single precision:
stored value of 255 indicated exponent of 255-127 = 128,
and 0 is 0 - 127 = -127 (can't be symmetric, because of zero)

Most positive exponent: 111...11, most negative: 00....000
oMakes some hardware/logic easier for exponents (easy
sorting/compare).
oNumeric value of stored IEEE FP is actually:

(-1)$ * (1 + significand) * 2exPonent - bias

31| 30] 29 28| 27| 26| 25 24 29] 22| 21| 20 19] 16] 17| 16] 15] 14] 13] 12/ 11| 10| 9] 6] 7| 6] 5| 4] 3] 2 1] 0
3s Expo bits: Signticand 23 bits

 

 

 

 

 

 

IEEE 754 - Single (32-bit) floating polnt format x
8 UNIVERSITY OF CAPE TOWN EReal to IEEE754 Single

Example
= Convert -0.75 to IEEE 754 Single Precision

O Calculation
= Sign is negative: so S = 1
= Binary fraction:
0.75*2 = 1.5 (IntPart = 1)
0.50*2 = 1.0 (IntPart = 1), so 0.75,, = 0.11,
=m Normalise: 0.11*2° = 1.1*2"
= Exponent: -1, add bias(127) = 126 = 01111110;
Oo Answer: 101111110 10000000000000000000000

 

 

: .
s  8bits 23 bits

31| 30| 29 28| 27| 26| 25 24 23] 22| 21/20 19] 18] 17| 16| 15| 14] 14] 12/11] 10| 9] @| z7| 6| 5| 4] 3| 2 1] 0
3 Exponent 3 bits Signficand i

 

 

 

 

IEEE 754 - Single (32461) floating polnt format

8 UNIVERSITY OF CAPE TOWN EIEEE754 Single to Real

Example

= What is the value of the FP number:

1 10000001 10010000000000000000000

oO Calculation

= Negative number (s=1)

= Biased exponent: 10000001 = 128+1 = 129

= Actual exponent = 129-127 =2

m Significand: 0.1001 = 0.5+0.0625 = 0.5625

o Result = -1 * (1 + 0.5625)*22 = -6.25,,

8 UNIVERSITY OF CAPE TOWNFor checking your work...

https ://www.h-
schmidt.net/FloatConverter/IEEE754.html

8 UNIVERSITY OF CAPE TOWNIEEE 754 Special Codes

IEEE 754 has special codes for zero, error conditions
(0/0 etc).

oZero: exponent and significand are zero.

olnfinity: exp = 1111...1111, significand = 0

ONaN (not a number): 0/0; exponent = 1111...1111,
significand != 0

oUnderflow/overflow conditions...

31| 30| 29 28| 27| 26| 25 24 29| 22| 21|20 19] 19] 17] 16] 15] 14] 13] 12| 14| 10] s| || z| 6| 5| a] al 2 1] o
s Exponent 8 bits Signticand 23 bits

 

 

 

 

I E 754 - Single (324b1t} floating point format

8 UNIVERSITY OF CAPE TOWNRange of Single Precision FPs

2000

Expcessible . .
Negative Negative Positive
Ovecflow Numbers Undecflow Undecflow

Expcessible
Positive Positive
Numbers Ovecflow

Wegative

 

= 126 4 1S
0 2 (1-2 3°2

Overflow means that values have grown too large forthe
representation, much in the same way that you can overflow integers.

Underflow is a less serious problem because is just denotes a loss of
precision, which is guaranteed to be closely approximated by zero.

8 UNIVERSITY OF CAPE TOWNFP Operations and Errors

Addition/Subtraction: normalise, match to larger
exponent then add, normalise.

oError conditions:

= Exponent Overflow Exponent bigger than max
permissable size; may be set to “infinity”.

= Exponent Underflow Negative exponent, smaller than
minimum size; may be set to zero.

= Significand Underflow Alignment may cause loss of
significant digits.

= Significand Overflow Addition may cause carry overflow;
realign significands.

8 UNIVERSITY OF CAPE TOWNBit/Byte Ordering

All you need to know about memory is that it's one
large array containing bytes (= 8 bits).
Endianness: ordering of bits or bytes in computer

= Big Endian: bytes ordered from most significant byte
(MSB) to least significant byte (LSB)

= Little Endian: bytes ordered from LSB to MSB
Example: how is 90AB12CD,, (32-bit)
represented? Split the 32 bit quantity into 4 bytes

= Big-Endian: 90AB12CD (lowest byte address stores
MSB)

= Little-Endian: CD12AB90 (lowest byte address stores
LSB)

Problems with multi-byte data: floats, ints, etc

Oo MIPS, IBM z/Architecture mainframes and —$
internet are Big-Endian, Intel x86 Little-Endian = {tle Encian

8 UNIVERSITY OF CAPE TOWNCharacter Representations

oO Characters represented using “character set”.
oO Examples:
= ASCII (7/8-bit)
m Unicode (16-bit, with variable-length encoding)
= EBCDIC (9-bit)
oO ASCII - American Standard Code for Information
Interchange

= Used to be widely used; 7-bits used for std characters etc. ;
extra for parity or foreign language.

8 UNIVERSITY OF CAPE TOWNNumber Representations

Numeric information is fundamental to computers — to
encode data and instructions.

Notation: N, for number N using radix r

m radix refers to the base — the number of possible symbols
for each digit.

General radix rnumber representation:
dod, dp.o--- dod4dp-d_;d_p...d_g

8 UNIVERSITY OF CAPE TOWNCharacter Codes

oO ASCII codes for Roman alphabet, numbers,
keyboard symbols and basic network control.

oO Unicode is very popular today: subsumes ASCII,
extensible, supported by most languages and OSes.

=m Handles many languages, not just Roman alphabet and
basic symbols.

8 UNIVERSITY OF CAPE TOWNBoolean Algebra & Logic

Modern computing devices are digital rather than

analog

= Use two discrete states to represent all entities: 0 and 1
= Call these two logical states TRUE and FALSE

All operations are on these values and can only yield these

values.

oGeorge Boole formalised such a logic algebra as “Boolean

Algebra”.

In a computer
chip, the
transistors aren't
isolated, they are
part of

an integrated
circuit (or microc
hip).

Computers use
transistors in
tandem with

oModern digital circuits are designed and optimised using this Boolean algebra

theory.

oWe implement “functions” (Such as add, compare, etc.) in

hardware, using corresponding Boolean express)
AL its

bP

8 UNIVERSITY OF CAPE TOWN

 

to make simple
decisions.

=Boolean Operators

oO There are 3 basic logic operators:

[on | AORE
NOT | _NOTA

 

The arguments (A, B) can only be TRUE or FALSE
O TRUE represented by 1; FALSE by 0

8 UNIVERSITY OF CAPE TOWNLogic Gate Symbols

 

HED
" P mo)
ZN / o »
6
Es 2
4 6
a A u

8 UNIVERSITY OF CAPE TOWNTruth Tables

A truth table shows the value of each operator (or combinations
thereof).

a AND is TRUE only if both arguments are TRUE

o OR is TRUE if either is TRUE

a NOT is a unary operator: inverts truth value

 

8 UNIVERSITY OF CAPE TOWN ENAND, NOR and XOR

O NAND is FALSE only if both args are TRUE
[NOT (A AND B)]
oO NOR is TRUE only if both args are FALSE
[NOT (A OR B)]
oO XOR is TRUE is either input is TRUE, but not both

a[s [Rs [eRe] nee

 

8 UNIVERSITY OF CAPE TOWNCheckpoint

oO What is the Boolean operation F represented by this
truth table?

 

8 UNIVERSITY OF CAPE TOWNCheckpoint

oO What is the Boolean operation F represented by this
truth table?

 

8 UNIVERSITY OF CAPE TOWNCheckpoint

oO What is the Boolean operation F represented by this
truth table?

 

8 UNIVERSITY OF CAPE TOWNLogic Gates

The Boolean operators have symbolic representations:
“logic gates”.

oThese are the building blocks for all computer circuits.
To work out which logic gates are required for an
operation, specify the function, F, using a truth table;
then derive the Boolean expression. Then simplify.

8 UNIVERSITY OF CAPE TOWNDecimal Codes

Common representation for humans.

Radix = 10.
= Possible values for digits: 0-9

Example:
1041.2,, = 17103 + 0102 + 4*101 + 1*10° + 2*107

An n-digit decimal number can represent values

8 UNIVERSITY OF CAPE TOWNWhat Boolean Expression is represented
by this truth table’:

F = F(A,B,C); F called “output variable”

 

8 UNIVERSITY OF CAPE TOWNFinding a Boolean Representation

F = F(A,B,C); F called “output variable”
oFind F values which are TRUE:

So, if A=0, B=1, C=0, then F = 1.

So, F, =A.B.C

That is, we know our output is TRUE for this

expression (from the table).

Also have F, = A.B.C and F, = A.B.C
F TRUE if F, TRUE or F, TRUE or F, TRUE

> F=F,+Fo+Fe,

Cases for F FALSE follows from F TRUE

8 UNIVERSITY OF CAPE TOWNAlgebraic Identities

Commutative: A.B = B.A and A+B = B+A
Distributive:

A.(B+C) = (A.B) + (A.C)

A+(B.C) = (A+B).(A+C)
Identity Elements: 1.A=Aand0+A=A
Inverse: AA =OandA+A=1
Associative:

A.(B.C) = (A.B).C and A+(B+C) = (A+B)+C
De Morgan's Laws:

A.B B=A + | Band

A+B = A.B

8 UNIVERSITY OF CAPE TOWNDe Morgans laws
Oo NOT (A AND B) = (NOT A) OR (NOT B)

[A|BIAB/A+B| NOT(AB) |NOTA+ NOT B
ofofo} oy tt
ott fous | tt

thofot sa | tt
Ee ee ee ee

 

8 UNIVERSITY OF CAPE TOWN EDe Morgans laws
Oo NOT (A OR B) = (NOT A) AND (NOT B)

ALS [AB/A+B | NOT(AsB) [NOTA AND NOTES
po pt

 

Useful for simplifying expressions

8 UNIVERSITY OF CAPE TOWN ECheckpoint: Real to IEEE754
Single precision

Convert 20.2 to IEEE 754 Single Precision

 

31| 30| 29 28| 27| 26| 25 24 23] 22| 21/20 19] 18] 17| 16| 15| 14] 14] 12/11] 10| 9] @| z7| 6| 5| 4] 3| 2 1] 0
Exponent 3 bits Signficand 23 bits

 

 

 

 

IEEE 754 - Single (32461) floating polnt format

8 UNIVERSITY OF CAPE TOWNCheckpoint: Real to IEEE754
Single precision

Convert 20.2 to IEEE 754 Single Precision

oO Answer: 0 10000011 01000011001100110011001
s  8bits 23 bits

Check with (-1)$* (1 + significand) * 2e*Ponent - bias

30| 26 28| 27| 26| 25 24 23 22| 21| 20 19] 18] 17| 16] 15| 14] 13] 12| 11] 10] 9] 8| 7| 6| 5] 4| 3| 2 1| 0
ts Signficand 23 bits

 

 

 

 

31
3

 

 

IEEE 754 - Single (32461) floating polnt format

8 UNIVERSITY OF CAPE TOWNIEEE754 Single to Real

Example
= What is the value of the FP number:
0 01111111 11100000000000000000000
Oo Calculation
= positive number (s=0)
= Biased exponent: 01111111 = 127
= Actual exponent = 127-127 =0
= Significand: 0.111 = 0.5+0.25+0.125 = 0.875

o Result = 1 * (1 + 0.875)*2° = 1.875,,

8 UNIVERSITY OF CAPE TOWNBinary Codes

Computers use presence/absence of voltage.
Radix = 2.
= Possible values for digits: 0 and 1

Example:
m 1001.1, = 1°29 + 0*27 + 0*21 + 172° + 1*21
= 9.545
m 11.01 = 1*2' + 1°29 + 0*21 4 1*2¢
= 3.25,5

n-bit binary number can represent numbers from
019 to (2-1) 19
Oo Largest 8-bit (unsigned) number: 11111111, = 255,,

8 UNIVERSITY OF CAPE TOWNDecimal to Binary Conversion

Algorithm:
quot = number;
i= 0;
repeat until quot ==
quot = quot/2;
digit | = remainder;
i++;

8 UNIVERSITY OF CAPE TOWN

rem 1
rem 0
rem 1
rem 0
rem 0
rem 1

Example:
Convert 37,, to binary.
Calculation:
o 37/2 =18
o 18/2 =9
o 9/2 =4
0 4/2 =2
o 2/2 =1
o1/2 =0
Result:

least sig. digit

most sig. digitQuick Decimal to Binary

Algorithm (“make change” algorithm):
= Leti= largest power of 2 less than or equal to the number.
=» N=N-2
= Set digit i of result to 1
= repeat until N ==

Example:
= Convert 37,, to binary.
= Calculation:

o N >= 32, so digit 5 is 1 and N=5

o N>=4, so digit 2 is 1 and N=1

o N >= 1, so digit 0 is 1 and N=0
= Result:

6 3749 = 100101,

ONote: Use this only to check your answers!

8 UNIVERSITY OF CAPE TOWN EConverting Fractional Numbers

oO Algorithm
i=0
repeat until N == 1.0 ori ==
N = FracPart(N);
N *= 2;
digit i = IntPart(N);
i++
o Example
= Convert 0.125,, to binary
= Calculation:

Oo 0.125*2 =0.25;  IntPart = 0 most significant digit
o 0.250*2 =0.50;  IntPart = 0
o 0.500*2 = 1.00; IntPart = 1 least significant digit

= Result: 0.125,,. = 0.001,
Convert integer and fractional parts separately.
o Many numbers cannot be represented accurately:
= 0.3) = 0.0[1001]..., (bracket repeats, limited by bit size)

8 UNIVERSITY OF CAPE TOWN EBinary Addition

Adding binary numbers:

m 140 =0+1 =1 Binary math works just like decimal math,
=» 0+0=0 except that the value of each bit can be only 0

= 1+1=Ocarry 1 or 1.
O Possibility of overflow
Add 109,, to 136,,:
01101101, + 10001000, = 11110101, = 245,,
Add 254,, to 249:
11111110, + 00000010, = [1]00000000, = 256,,

Oo We only have 8 bits to store answer...so it's zero!
oO Program can generate an “exception” to let us know.
Oo Usually number of bits is quite large: 32 bits or 64 bits.

8 UNIVERSITY OF CAPE TOWN E